<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Solana Token Multisender</title>

  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    #log-output::-webkit-scrollbar { width:4px; }
    #log-output::-webkit-scrollbar-track { background:#334155; }
    #log-output::-webkit-scrollbar-thumb { background:#64748b; border-radius:4px; }
  </style>
</head>
<body class="bg-slate-900 text-slate-100 font-sans p-4 md:p-8 min-h-screen">
  <div class="max-w-5xl mx-auto">
    <header class="mb-8">
      <h1 class="text-3xl md:text-4xl font-bold text-white mb-2">Solana Token Multisender</h1>
      <p class="text-slate-400">Connect your wallet, paste the mint address, and send SPL tokens to many recipients. Includes progress, retry logic, and trimming utilities.</p>
    </header>

    <div class="bg-yellow-900 border border-yellow-700 text-yellow-100 px-4 py-3 rounded-lg mb-6 shadow" role="alert">
      <p class="font-bold">Use at Your Own Risk!</p>
      <p class="text-sm">Always test on Devnet before Mainnet. Verify all addresses and amounts.</p>
    </div>

    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
      <!-- Left: inputs -->
      <div class="bg-slate-800 p-6 rounded-lg shadow flex flex-col gap-6">
        <div>
          <h2 class="text-lg font-semibold mb-2">1. Connect Wallet & Select Cluster</h2>
          <button id="connect-wallet-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition">
            Connect Wallet
          </button>
          <select id="cluster-select" class="w-full bg-slate-700 text-white border border-slate-600 rounded-lg p-2 mt-2">
            <option value="https://api.devnet.solana.com">Devnet (Testing)</option>
            <option value="https://api.mainnet-beta.solana.com">Mainnet-beta (Public)</option>
          </select>

          <p class="text-xs text-slate-400 mt-2">Primary RPC for sending is selected in the RPC Manager below. The dropdown here sets the cluster only.</p>

          <p id="connect-hint" class="text-xs text-slate-400 mt-2">Please connect your wallet first to enable the form.</p>
        </div>

        <!-- RPC Nodes for Verification Section -->
        <div class="border-t border-slate-700 pt-4">
          <div class="flex items-center justify-between mb-2">
            <h2 class="text-lg font-semibold">RPC Nodes for Verification</h2>
            <button id="toggle-rpc-section" class="text-slate-400 hover:text-white text-sm">
              [Show/Hide]
            </button>
          </div>
          <div id="rpc-verification-section" class="space-y-3" style="display: none;">
            <div class="bg-blue-900/20 border border-blue-700/40 rounded p-2 text-xs text-blue-200">
              <strong>‚ÑπÔ∏è Consensus Verification:</strong> After each transaction, we check multiple RPC endpoints to ensure the transaction is finalized.
              At least <span id="min-consensus-display">2</span> out of <span id="total-endpoints-display">3</span> endpoints must confirm for success.
              <a href="#" id="info-consensus-link" class="underline">Learn more</a>
            </div>

            <!-- Consensus Threshold Setting -->
            <div>
              <label class="block text-sm font-medium text-slate-300 mb-1">
                Minimum Consensus Threshold
                <span class="text-slate-400 text-xs">(default: 2)</span>
              </label>
              <input id="min-consensus-threshold" type="number" value="2" min="1" max="10"
                     class="w-full bg-slate-700 text-white border border-slate-600 rounded p-2">
              <p class="text-xs text-slate-400 mt-1">
                Number of endpoints that must confirm a transaction for it to be considered successful.
              </p>
            </div>

            <!-- Endpoint List -->
            <div>
              <label class="block text-sm font-medium text-slate-300 mb-2">
                Selected RPC Endpoints (min 3 required)
              </label>
              <div id="rpc-endpoints-list" class="space-y-2 max-h-64 overflow-y-auto">
                <!-- Endpoints will be rendered here -->
              </div>
            </div>

            <!-- Add Endpoint Form -->
            <div class="border-t border-slate-700 pt-3">
              <div class="flex justify-between items-center mb-2">
                <button id="toggle-add-endpoint" class="text-sm text-indigo-400 hover:text-indigo-300">
                  + Add Custom Endpoint
                </button>
                <button id="reset-endpoints-btn" class="text-sm text-slate-400 hover:text-slate-200">
                  Reset to Defaults
                </button>
              </div>
              <div id="add-endpoint-form" class="mt-2 space-y-2" style="display: none;">
                <input id="new-endpoint-label" type="text" placeholder="Endpoint Label (e.g., 'My Helius Node')"
                       class="w-full bg-slate-700 text-white border border-slate-600 rounded p-2 text-sm">
                <input id="new-endpoint-url" type="text" placeholder="RPC URL (e.g., https://...)"
                       class="w-full bg-slate-700 text-white border border-slate-600 rounded p-2 text-sm">
                <input id="new-endpoint-apikey" type="password" placeholder="API Key (optional)"
                       class="w-full bg-slate-700 text-white border border-slate-600 rounded p-2 text-sm">
                <div class="flex gap-2">
                  <button id="add-endpoint-btn" 
                          class="flex-1 bg-indigo-600 hover:bg-indigo-700 text-white text-sm py-2 px-3 rounded transition">
                    Add Endpoint
                  </button>
                  <button id="cancel-add-endpoint-btn" 
                          class="flex-1 bg-slate-600 hover:bg-slate-700 text-white text-sm py-2 px-3 rounded transition">
                    Cancel
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div>
          <label for="token-mint-address" class="block text-sm font-medium text-slate-300 mb-1">2. Token Mint Address</label>
          <input id="token-mint-address" type="text" disabled
                 autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" inputmode="text"
                 class="w-full bg-slate-700 text-white border border-slate-600 rounded-lg p-2"
                 placeholder="Base58 mint address (e.g., EPjFW...)">
        </div>

        <div>
          <label for="batch-size" class="block text-sm font-medium text-slate-300 mb-1">3. Transfers per Transaction (Batch Size)</label>
          <input id="batch-size" type="number" value="5" min="1" max="12" disabled
                 class="w-full bg-slate-700 text-white border border-slate-600 rounded-lg p-2">
          <p class="text-xs text-slate-400 mt-1">If creating many ATAs, use 3‚Äì6 to avoid tx size limits.</p>
        </div>

        <div>
          <label for="recipients-list" class="block text-sm font-medium text-slate-300 mb-1">
            4. Recipients (one per line: Address, Amount)
          </label>
          <textarea id="recipients-list" rows="10" disabled
            class="w-full bg-slate-700 text-white border border-slate-600 rounded-lg p-2 font-mono text-sm"
            placeholder="Address, Amount
Address, Amount
Example:
Hc4q...abcd, 10.5
CxtR...wxyz, 2"></textarea>
          <button id="trim-recipients-btn"
                  type="button"
                  class="mt-2 bg-slate-600 hover:bg-slate-700 text-white text-xs py-1 px-3 rounded transition">
            Trim Recipients
          </button>
          <p class="text-xs text-slate-400 mt-1">
            Trims leading/trailing spaces, removes blank lines & unicode spaces, and strips spaces inside addresses.
          </p>
        </div>

        <button id="send-btn" disabled
          class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition disabled:bg-gray-500">
          Connect Wallet to Start
        </button>

        <!-- Progress -->
        <div class="mt-4">
          <div class="flex items-center justify-between text-sm text-slate-300 mb-1">
            <span>Progress</span>
            <span id="progress-label">0 / 0 (0%)</span>
          </div>
          <div id="progress-bar-wrapper" class="w-full bg-slate-700 h-3 rounded overflow-hidden">
            <div id="progress-bar" class="bg-green-500 h-3 w-0 transition-all duration-300"></div>
          </div>
          <div class="grid grid-cols-3 gap-2 text-xs text-slate-400 mt-2">
            <div>Completed: <span id="count-completed">0</span></div>
            <div>Pending: <span id="count-pending">0</span></div>
            <div>Failed: <span id="count-failed">0</span></div>
          </div>
        </div>
      </div>

      <!-- Right: log -->
      <div class="bg-slate-800 p-6 rounded-lg shadow flex flex-col">
        <h2 class="text-lg font-semibold mb-2 text-white">Log & Progress</h2>
        
        <!-- Multi-RPC Consensus Verification Info -->
        <div class="bg-blue-900/30 border border-blue-700/50 rounded-lg p-3 mb-3 text-xs">
          <div class="flex items-start gap-2">
            <span class="text-blue-400 font-bold text-sm">üîç</span>
            <div class="text-blue-200">
              <strong>Multi-RPC Consensus Verification:</strong> Each transaction is verified across multiple RPC endpoints for maximum security and reliability.
              <span class="text-blue-300 block mt-1">
                ‚úÖ Green = Consensus reached (enough endpoints confirmed) | 
                ‚ö†Ô∏è Yellow = Warning (consensus not reached or nodes out of sync)
              </span>
            </div>
          </div>
        </div>

        <div id="log-output"
             class="w-full h-96 bg-slate-900 rounded-lg p-4 font-mono text-sm text-slate-300 overflow-y-auto whitespace-pre-wrap break-words">
          Welcome! Connect your wallet to begin.
        </div>
        <button id="clear-log-btn"
                class="mt-4 bg-slate-600 hover:bg-slate-700 text-white text-sm py-2 px-4 rounded-lg transition">
          Clear Log
        </button>
      </div>
    </div>

    <footer class="text-center text-slate-500 mt-8 text-sm">
      Includes automatic retries with batch splitting, progress bar, custom RPC support, and manual + passive trimming.
    </footer>
  </div>

  <!-- Use ESM imports to avoid global splToken issues -->
  <script type="module">
    import { Connection, PublicKey, Transaction } from 'https://esm.sh/@solana/web3.js@1.95.3';
    import {
      getMint,
      getAssociatedTokenAddress,
      createAssociatedTokenAccountInstruction,
      createTransferCheckedInstruction,
      TOKEN_PROGRAM_ID,
      TOKEN_2022_PROGRAM_ID,
      ASSOCIATED_TOKEN_PROGRAM_ID,
    } from 'https://esm.sh/@solana/spl-token@0.4.6';

    /* -------------------- UI References -------------------- */
    const connectBtn      = document.getElementById('connect-wallet-btn');
    const clusterSelect   = document.getElementById('cluster-select');
    const mintInput       = document.getElementById('token-mint-address');
    const recipientsInput = document.getElementById('recipients-list');
    const trimRecipientsBtn = document.getElementById('trim-recipients-btn');
    const batchSizeInput  = document.getElementById('batch-size');
    const sendBtn         = document.getElementById('send-btn');
    const hint            = document.getElementById('connect-hint');
    const clearLogBtn     = document.getElementById('clear-log-btn');
    const logOutput       = document.getElementById('log-output');

    // Progress UI
    const progressBar     = document.getElementById('progress-bar');
    const progressLabel   = document.getElementById('progress-label');
    const countCompleted  = document.getElementById('count-completed');
    const countPending    = document.getElementById('count-pending');
    const countFailed     = document.getElementById('count-failed');

    /* -------------------- State -------------------- */
    let provider = null; // Phantom provider
    let wallet   = null; // PublicKey
    let connection = null;

    // Mint/session state set during send
    let mintPubkey = null;
    let tokenProgramId = TOKEN_PROGRAM_ID;
    let decimals = 0;
    let senderAta = null;

    // Backup RPC connections for cross-RPC verification (legacy, replaced by multi-endpoint system)
    let backupConnection = null;

    // Results
    let allRecipients = [];
    let completedRecipients = new Set();
    let failedRecipients = [];

    /* -------------------- RPC Endpoint Management -------------------- */
    
    // Default RPC endpoints by cluster
    const DEFAULT_RPC_ENDPOINTS = {
      mainnet: [
        { id: 'mainnet-solana-official', label: 'Solana Official (Mainnet)', url: 'https://api.mainnet-beta.solana.com', apiKey: '', enabled: true, isDefault: true },
        { id: 'mainnet-helius-public', label: 'Helius (Mainnet - Public)', url: 'https://mainnet.helius-rpc.com/?api-key=fda76be1-7d09-4880-80db-837831934193', apiKey: '', enabled: true, isDefault: true },
        { id: 'mainnet-quicknode', label: 'QuickNode (Mainnet - Demo)', url: 'https://api.mainnet-beta.solana.com', apiKey: '', enabled: true, isDefault: true },
      ],
      devnet: [
        { id: 'devnet-solana-official', label: 'Solana Official (Devnet)', url: 'https://api.devnet.solana.com', apiKey: '', enabled: true, isDefault: true },
        { id: 'devnet-helius', label: 'Helius (Devnet)', url: 'https://devnet.helius-rpc.com/?api-key=fda76be1-7d09-4880-80db-837831934193', apiKey: '', enabled: true, isDefault: true },
        { id: 'devnet-quicknode', label: 'QuickNode (Devnet - Demo)', url: 'https://api.devnet.solana.com', apiKey: '', enabled: true, isDefault: true },
      ],
      testnet: [
        { id: 'testnet-solana-official', label: 'Solana Official (Testnet)', url: 'https://api.testnet.solana.com', apiKey: '', enabled: true, isDefault: true },
        { id: 'testnet-helius', label: 'Helius (Testnet)', url: 'https://testnet.helius-rpc.com', apiKey: '', enabled: false, isDefault: true },
        { id: 'testnet-quicknode', label: 'QuickNode (Testnet - Demo)', url: 'https://api.testnet.solana.com', apiKey: '', enabled: false, isDefault: true },
      ]
    };

    // User's configured endpoints (loaded from localStorage)
    let userRpcEndpoints = { mainnet: [], devnet: [], testnet: [] };
    
    // Current cluster for endpoint selection
    let currentCluster = 'devnet';

    // Minimum consensus threshold (how many endpoints must agree)
    let minConsensusThreshold = 2;

    // Primary endpoint selection per cluster (stored by endpoint id)
    let primaryEndpointByCluster = { mainnet: null, devnet: null, testnet: null };

    // Editing state for inline edit mode
    let editingEndpointIndex = null;

    /* -------------------- RPC Endpoint Functions -------------------- */
    
    // Load endpoints from localStorage or initialize with defaults
    function loadRpcEndpoints() {
      const stored = localStorage.getItem('rpcEndpointsConfig');
      if (stored) {
        try {
          const parsed = JSON.parse(stored);
          userRpcEndpoints = parsed;
          // Ensure all clusters exist
          if (!userRpcEndpoints.mainnet) userRpcEndpoints.mainnet = [...DEFAULT_RPC_ENDPOINTS.mainnet];
          if (!userRpcEndpoints.devnet) userRpcEndpoints.devnet = [...DEFAULT_RPC_ENDPOINTS.devnet];
          if (!userRpcEndpoints.testnet) userRpcEndpoints.testnet = [...DEFAULT_RPC_ENDPOINTS.testnet];
        } catch (e) {
          console.error('Failed to parse stored RPC endpoints:', e);
          userRpcEndpoints = {
            mainnet: [...DEFAULT_RPC_ENDPOINTS.mainnet],
            devnet: [...DEFAULT_RPC_ENDPOINTS.devnet],
            testnet: [...DEFAULT_RPC_ENDPOINTS.testnet]
          };
        }
      } else {
        // Initialize with defaults
        userRpcEndpoints = {
          mainnet: [...DEFAULT_RPC_ENDPOINTS.mainnet],
          devnet: [...DEFAULT_RPC_ENDPOINTS.devnet],
          testnet: [...DEFAULT_RPC_ENDPOINTS.testnet]
        };
      }
      
      // Load consensus threshold
      const storedThreshold = localStorage.getItem('minConsensusThreshold');
      if (storedThreshold) {
        minConsensusThreshold = parseInt(storedThreshold, 10) || 2;
      }

      // Load primary endpoint selections
      const storedPrimary = localStorage.getItem('primaryEndpointByCluster');
      if (storedPrimary) {
        try {
          primaryEndpointByCluster = JSON.parse(storedPrimary);
        } catch (e) {
          console.error('Failed to parse stored primary endpoints:', e);
          primaryEndpointByCluster = { mainnet: null, devnet: null, testnet: null };
        }
      }
    }

    // Save endpoints to localStorage
    function saveRpcEndpoints() {
      localStorage.setItem('rpcEndpointsConfig', JSON.stringify(userRpcEndpoints));
      localStorage.setItem('minConsensusThreshold', minConsensusThreshold.toString());
      localStorage.setItem('primaryEndpointByCluster', JSON.stringify(primaryEndpointByCluster));
    }

    // Get current cluster name based on dropdown selection
    function getCurrentCluster() {
      const dropdownUrl = clusterSelect.value;
      
      if (dropdownUrl.includes('devnet')) return 'devnet';
      if (dropdownUrl.includes('testnet')) return 'testnet';
      return 'mainnet';
    }

    // Get enabled endpoints for current cluster
    function getEnabledEndpoints() {
      const cluster = getCurrentCluster();
      const endpoints = userRpcEndpoints[cluster] || [];
      return endpoints.filter(ep => ep.enabled);
    }

    // Build full URL with API key if needed
    function buildEndpointUrl(endpoint) {
      if (!endpoint.apiKey) return endpoint.url;
      
      // If URL already has query params, append with &
      if (endpoint.url.includes('?')) {
        return `${endpoint.url}&api-key=${endpoint.apiKey}`;
      }
      // Otherwise, add with ?
      return `${endpoint.url}?api-key=${endpoint.apiKey}`;
    }

    // Obfuscate API key for display
    function obfuscateApiKey(key) {
      if (!key || key.length < 8) return '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
      return key.slice(0, 4) + '‚Ä¢‚Ä¢‚Ä¢‚Ä¢' + key.slice(-4);
    }

    // Initialize connection using primary endpoint or fallback
    function initializeConnection() {
      const cluster = getCurrentCluster();
      const endpoints = userRpcEndpoints[cluster] || [];
      
      // Find primary endpoint
      const primaryId = primaryEndpointByCluster[cluster];
      let selectedEndpoint = null;
      
      if (primaryId) {
        selectedEndpoint = endpoints.find(ep => ep.id === primaryId);
      }
      
      // Fallback to first enabled endpoint
      if (!selectedEndpoint) {
        selectedEndpoint = endpoints.find(ep => ep.enabled);
      }
      
      // Final fallback to first endpoint
      if (!selectedEndpoint && endpoints.length > 0) {
        selectedEndpoint = endpoints[0];
      }
      
      if (selectedEndpoint) {
        const url = buildEndpointUrl(selectedEndpoint);
        connection = new Connection(url, 'confirmed');
        log(`Primary RPC set to: ${selectedEndpoint.label}`, 'info');
      } else {
        // No endpoints configured, fall back to dropdown selection
        const dropdownUrl = clusterSelect.value;
        connection = new Connection(dropdownUrl, 'confirmed');
        log(`Using default RPC from dropdown: ${dropdownUrl}`, 'info');
      }
    }

    // Render endpoint list UI
    function renderEndpointsList() {
      const cluster = getCurrentCluster();
      const endpoints = userRpcEndpoints[cluster] || [];
      const container = document.getElementById('rpc-endpoints-list');
      
      if (endpoints.length === 0) {
        container.innerHTML = '<p class="text-slate-400 text-sm">No endpoints configured for this cluster.</p>';
        return;
      }

      const primaryId = primaryEndpointByCluster[cluster];

      container.innerHTML = endpoints.map((ep, idx) => {
        const isEditing = editingEndpointIndex === idx;
        const isPrimary = ep.id === primaryId;
        
        if (isEditing) {
          // Edit mode
          const escapeHtml = (str) => {
            const div = document.createElement('div');
            div.textContent = str || '';
            return div.innerHTML;
          };
          
          return `
            <div class="bg-slate-700 rounded p-3">
              <div class="space-y-2">
                <input id="edit-label-${idx}" type="text" value="${escapeHtml(ep.label)}" 
                       placeholder="Label"
                       class="w-full bg-slate-600 text-white border border-slate-500 rounded p-2 text-sm">
                <input id="edit-url-${idx}" type="text" value="${escapeHtml(ep.url)}" 
                       placeholder="RPC URL"
                       class="w-full bg-slate-600 text-white border border-slate-500 rounded p-2 text-sm">
                <input id="edit-apikey-${idx}" type="text" value="${escapeHtml(ep.apiKey || '')}" 
                       placeholder="API Key (optional)"
                       class="w-full bg-slate-600 text-white border border-slate-500 rounded p-2 text-sm">
                <div class="flex gap-2">
                  <button onclick="saveEndpoint(${idx})" 
                          class="flex-1 bg-green-600 hover:bg-green-700 text-white text-sm py-1 px-3 rounded transition">
                    Save
                  </button>
                  <button onclick="cancelEditEndpoint()" 
                          class="flex-1 bg-slate-600 hover:bg-slate-700 text-white text-sm py-1 px-3 rounded transition">
                    Cancel
                  </button>
                </div>
              </div>
            </div>
          `;
        } else {
          // Display mode
          const displayUrl = ep.url.length > 50 ? ep.url.slice(0, 47) + '...' : ep.url;
          const hasApiKey = ep.apiKey && ep.apiKey.trim() !== '';
          const apiKeyDisplay = hasApiKey ? obfuscateApiKey(ep.apiKey) : 'None';
          
          return `
            <div class="bg-slate-700 rounded p-3 flex items-start justify-between gap-2">
              <div class="flex-1 min-w-0">
                <div class="flex items-center gap-2 mb-1">
                  <input type="radio" name="primary-endpoint-${cluster}" 
                         ${isPrimary ? 'checked' : ''}
                         onchange="setPrimaryEndpoint(${idx})"
                         class="rounded bg-slate-600 border-slate-500"
                         title="Set as Primary">
                  <input type="checkbox" id="endpoint-enabled-${idx}" 
                         ${ep.enabled ? 'checked' : ''}
                         class="rounded bg-slate-600 border-slate-500"
                         onchange="toggleEndpointEnabled(${idx})">
                  <label for="endpoint-enabled-${idx}" class="text-sm font-medium text-white truncate">
                    ${ep.label}
                  </label>
                  ${ep.isDefault ? '<span class="text-xs bg-blue-600 text-white px-1 rounded">Default</span>' : ''}
                  ${isPrimary ? '<span class="text-xs bg-green-600 text-white px-1 rounded">Primary</span>' : ''}
                </div>
                <div class="text-xs text-slate-400 truncate" title="${ep.url}">
                  URL: ${displayUrl}
                </div>
                <div class="text-xs text-slate-400">
                  API Key: ${apiKeyDisplay}
                </div>
              </div>
              <div class="flex flex-col gap-1">
                <button onclick="editEndpoint(${idx})" class="text-indigo-400 hover:text-indigo-300 text-xs" title="Edit">‚úé</button>
                ${idx > 0 ? `<button onclick="moveEndpointUp(${idx})" class="text-slate-400 hover:text-white text-xs" title="Move up">‚Üë</button>` : '<span class="text-xs invisible">‚Üë</span>'}
                ${idx < endpoints.length - 1 ? `<button onclick="moveEndpointDown(${idx})" class="text-slate-400 hover:text-white text-xs" title="Move down">‚Üì</button>` : '<span class="text-xs invisible">‚Üì</span>'}
                ${!ep.isDefault ? `<button onclick="removeEndpoint(${idx})" class="text-red-400 hover:text-red-300 text-xs" title="Remove">‚úï</button>` : '<span class="text-xs invisible">‚úï</span>'}
              </div>
            </div>
          `;
        }
      }).join('');

      // Update display counters
      const enabledCount = endpoints.filter(ep => ep.enabled).length;
      document.getElementById('total-endpoints-display').textContent = enabledCount;
      document.getElementById('min-consensus-display').textContent = minConsensusThreshold;
    }

    // Edit endpoint - enter edit mode
    window.editEndpoint = function(idx) {
      editingEndpointIndex = idx;
      renderEndpointsList();
    };

    // Cancel edit mode
    window.cancelEditEndpoint = function() {
      editingEndpointIndex = null;
      renderEndpointsList();
    };

    // Save endpoint changes
    window.saveEndpoint = function(idx) {
      const cluster = getCurrentCluster();
      const endpoints = userRpcEndpoints[cluster];
      if (!endpoints || !endpoints[idx]) return;

      let label = document.getElementById(`edit-label-${idx}`)?.value.trim() || '';
      let url = document.getElementById(`edit-url-${idx}`)?.value.trim() || '';
      let apiKey = document.getElementById(`edit-apikey-${idx}`)?.value.trim() || '';

      if (!label || !url) {
        alert('Label and URL are required.');
        return;
      }

      // Extract API key from URL if present
      try {
        if (url.includes('api-key=') || url.includes('apikey=')) {
          const urlObj = new URL(url);
          const keyFromUrl = urlObj.searchParams.get('api-key') || urlObj.searchParams.get('apikey');
          if (keyFromUrl && !apiKey) {
            apiKey = keyFromUrl;
          }
          // Remove API key from URL
          urlObj.searchParams.delete('api-key');
          urlObj.searchParams.delete('apikey');
          url = urlObj.toString();
        }
      } catch (e) {
        console.error('Error parsing URL:', e);
      }

      endpoints[idx].label = label;
      endpoints[idx].url = url;
      endpoints[idx].apiKey = apiKey;

      editingEndpointIndex = null;
      saveRpcEndpoints();
      renderEndpointsList();
      
      // Re-initialize connection if this is the primary endpoint
      const primaryId = primaryEndpointByCluster[cluster];
      if (endpoints[idx].id === primaryId) {
        initializeConnection();
      }
      
      log(`Endpoint updated: ${label}`, 'success');
    };

    // Set primary endpoint
    window.setPrimaryEndpoint = function(idx) {
      const cluster = getCurrentCluster();
      const endpoints = userRpcEndpoints[cluster];
      if (!endpoints || !endpoints[idx]) return;

      primaryEndpointByCluster[cluster] = endpoints[idx].id;
      saveRpcEndpoints();
      renderEndpointsList();
      initializeConnection();
      log(`Primary endpoint set to: ${endpoints[idx].label}`, 'success');
    };

    // Toggle endpoint enabled state
    window.toggleEndpointEnabled = function(idx) {
      const cluster = getCurrentCluster();
      const endpoints = userRpcEndpoints[cluster];
      if (endpoints && endpoints[idx]) {
        endpoints[idx].enabled = !endpoints[idx].enabled;
        saveRpcEndpoints();
        renderEndpointsList();
        
        // Re-initialize connection if this affects the primary endpoint
        const primaryId = primaryEndpointByCluster[cluster];
        if (endpoints[idx].id === primaryId) {
          initializeConnection();
        }
      }
    };

    // Move endpoint up in list
    window.moveEndpointUp = function(idx) {
      const cluster = getCurrentCluster();
      const endpoints = userRpcEndpoints[cluster];
      if (idx > 0 && endpoints) {
        [endpoints[idx - 1], endpoints[idx]] = [endpoints[idx], endpoints[idx - 1]];
        saveRpcEndpoints();
        renderEndpointsList();
        
        // Re-initialize connection if primary is affected
        const primaryId = primaryEndpointByCluster[cluster];
        if (endpoints[idx].id === primaryId || endpoints[idx - 1].id === primaryId) {
          initializeConnection();
        }
      }
    };

    // Move endpoint down in list
    window.moveEndpointDown = function(idx) {
      const cluster = getCurrentCluster();
      const endpoints = userRpcEndpoints[cluster];
      if (idx < endpoints.length - 1 && endpoints) {
        [endpoints[idx], endpoints[idx + 1]] = [endpoints[idx + 1], endpoints[idx]];
        saveRpcEndpoints();
        renderEndpointsList();
        
        // Re-initialize connection if primary is affected
        const primaryId = primaryEndpointByCluster[cluster];
        if (endpoints[idx].id === primaryId || endpoints[idx + 1].id === primaryId) {
          initializeConnection();
        }
      }
    };

    // Remove endpoint
    window.removeEndpoint = function(idx) {
      const cluster = getCurrentCluster();
      const endpoints = userRpcEndpoints[cluster];
      if (endpoints && endpoints[idx] && !endpoints[idx].isDefault) {
        if (confirm(`Remove endpoint "${endpoints[idx].label}"?`)) {
          const removedId = endpoints[idx].id;
          endpoints.splice(idx, 1);
          
          // Clear primary if we removed it
          if (primaryEndpointByCluster[cluster] === removedId) {
            primaryEndpointByCluster[cluster] = null;
          }
          
          saveRpcEndpoints();
          renderEndpointsList();
          initializeConnection();
        }
      }
    };

    /* -------------------- Logging -------------------- */
    function log(msg, type='info') {
      const ts = new Date().toLocaleTimeString();
      const color = type === 'error' ? 'text-red-400'
                  : type === 'success' ? 'text-green-400'
                  : type === 'warning' ? 'text-yellow-400'
                  : 'text-slate-300';
      logOutput.innerHTML += `\n<div class="${color}"><span class="text-slate-500">${ts}:</span> ${msg}</div>`;
      logOutput.scrollTop = logOutput.scrollHeight;
    }
    clearLogBtn.addEventListener('click', () => { logOutput.innerHTML = 'Log cleared.'; });

    /* -------------------- UI Helpers -------------------- */
    function setUi(connected) {
      mintInput.disabled       = !connected;
      recipientsInput.disabled = !connected;
      batchSizeInput.disabled  = !connected;
      sendBtn.disabled         = !connected;
      sendBtn.textContent      = connected ? 'Prepare & Send Transactions' : 'Connect Wallet to Start';
      hint.textContent         = connected
        ? 'Wallet connected. Enter mint & recipients.'
        : 'Please connect your wallet first to enable the form.';
    }

    function updateProgress() {
      const total  = allRecipients.length;
      const done   = completedRecipients.size;
      const failed = failedRecipients.length;
      const pending = Math.max(0, total - done - failed);
      const pct = total > 0 ? Math.round((done / total) * 100) : 0;

      progressBar.style.width = pct + '%';
      progressLabel.textContent = `${done} / ${total} (${pct}%)`;
      countCompleted.textContent = String(done);
      countPending.textContent   = String(pending);
      countFailed.textContent    = String(failed);
    }

    function resetProgress() {
      allRecipients = [];
      completedRecipients = new Set();
      failedRecipients = [];
      updateProgress();
    }

    /* -------------------- RPC Management UI Event Listeners -------------------- */
    
    // Toggle RPC section visibility
    document.getElementById('toggle-rpc-section')?.addEventListener('click', () => {
      const section = document.getElementById('rpc-verification-section');
      if (section.style.display === 'none') {
        section.style.display = 'block';
        renderEndpointsList();
      } else {
        section.style.display = 'none';
      }
    });

    // Toggle add endpoint form
    document.getElementById('toggle-add-endpoint')?.addEventListener('click', () => {
      const form = document.getElementById('add-endpoint-form');
      form.style.display = form.style.display === 'none' ? 'block' : 'none';
    });

    // Cancel add endpoint
    document.getElementById('cancel-add-endpoint-btn')?.addEventListener('click', () => {
      document.getElementById('add-endpoint-form').style.display = 'none';
      document.getElementById('new-endpoint-label').value = '';
      document.getElementById('new-endpoint-url').value = '';
      document.getElementById('new-endpoint-apikey').value = '';
    });

    // Add new endpoint
    document.getElementById('add-endpoint-btn')?.addEventListener('click', () => {
      const label = document.getElementById('new-endpoint-label').value.trim();
      let url = document.getElementById('new-endpoint-url').value.trim();
      let apiKey = document.getElementById('new-endpoint-apikey').value.trim();

      if (!label || !url) {
        alert('Please provide both a label and URL for the endpoint.');
        return;
      }

      // Auto-extract API key from URL if present
      if (url.includes('api-key=') || url.includes('apikey=')) {
        const urlObj = new URL(url);
        const keyFromUrl = urlObj.searchParams.get('api-key') || urlObj.searchParams.get('apikey');
        if (keyFromUrl && !apiKey) {
          apiKey = keyFromUrl;
          // Remove API key from URL to store separately
          urlObj.searchParams.delete('api-key');
          urlObj.searchParams.delete('apikey');
          url = urlObj.toString();
        }
      }

      const cluster = getCurrentCluster();
      const newEndpoint = {
        id: `custom-${Date.now()}`,
        label,
        url,
        apiKey,
        enabled: true,
        isDefault: false
      };

      userRpcEndpoints[cluster].push(newEndpoint);
      saveRpcEndpoints();
      renderEndpointsList();

      // Clear form
      document.getElementById('new-endpoint-label').value = '';
      document.getElementById('new-endpoint-url').value = '';
      document.getElementById('new-endpoint-apikey').value = '';
      document.getElementById('add-endpoint-form').style.display = 'none';

      log(`Added new RPC endpoint: ${label}`, 'success');
    });

    // Update consensus threshold
    document.getElementById('min-consensus-threshold')?.addEventListener('change', (e) => {
      const val = parseInt(e.target.value, 10);
      if (val >= 1 && val <= 10) {
        minConsensusThreshold = val;
        saveRpcEndpoints();
        renderEndpointsList();
        log(`Consensus threshold updated to ${val}`, 'info');
      }
    });

    // Cluster change should update endpoint list and connection
    clusterSelect.addEventListener('change', () => {
      currentCluster = getCurrentCluster();
      const section = document.getElementById('rpc-verification-section');
      if (section.style.display !== 'none') {
        renderEndpointsList();
      }
      initializeConnection();
    });

    // Reset endpoints to defaults for current cluster
    document.getElementById('reset-endpoints-btn')?.addEventListener('click', () => {
      const cluster = getCurrentCluster();
      if (confirm(`Reset all endpoints for ${cluster} to defaults? This will remove all custom endpoints for this cluster.`)) {
        userRpcEndpoints[cluster] = JSON.parse(JSON.stringify(DEFAULT_RPC_ENDPOINTS[cluster]));
        primaryEndpointByCluster[cluster] = null;
        saveRpcEndpoints();
        renderEndpointsList();
        initializeConnection();
        log(`Endpoints reset to defaults for ${cluster}`, 'success');
      }
    });

    // Info link for consensus explanation
    document.getElementById('info-consensus-link')?.addEventListener('click', (e) => {
      e.preventDefault();
      alert(
        'Consensus Verification Explained:\n\n' +
        'After each transaction is confirmed, we query multiple independent RPC endpoints to verify the transaction is finalized.\n\n' +
        'Why? Different RPC providers may have slightly different views of the blockchain state. By requiring multiple endpoints to agree, we ensure greater confidence that your transaction succeeded.\n\n' +
        'Minimum Consensus Threshold: The number of endpoints that must report "finalized" status for the transaction to be considered successful.\n\n' +
        'Example: With 3 endpoints and threshold of 2, at least 2 must confirm the transaction.\n\n' +
        'Recommendation: Use at least 3 endpoints from different providers (e.g., Solana official, Helius, QuickNode) for best reliability.'
      );
    });

    /* -------------------- Initialization -------------------- */
    document.addEventListener('DOMContentLoaded', () => {
      // Load RPC endpoints configuration
      loadRpcEndpoints();
      
      // Initialize connection with primary endpoint
      initializeConnection();
      
      // Set initial consensus threshold in UI
      const thresholdInput = document.getElementById('min-consensus-threshold');
      if (thresholdInput) {
        thresholdInput.value = minConsensusThreshold;
      }
      
      setUi(false);
      resetProgress();
    });

    /* -------------------- Amount Helpers (BigInt) -------------------- */
    function decimalToAmount(str, decimals) {
      const s = String(str).trim();
      if (!/^\d+(?:\.\d+)?$/.test(s)) throw new Error(`Invalid amount: ${str}`);
      const [whole, fracRaw=''] = s.split('.');
      const frac = (fracRaw + '0'.repeat(decimals)).slice(0, decimals);
      return BigInt(whole + frac);
    }

    function formatAmount(bi, decimals) {
      const s = bi.toString();
      if (decimals === 0) return s;
      const pad = s.padStart(decimals + 1, '0');
      const whole = pad.slice(0, -decimals);
      const frac  = pad.slice(-decimals).replace(/0+$/,'');
      return frac ? `${whole}.${frac}` : whole;
    }

    /* -------------------- Recipients Normalization -------------------- */
    // Robust normalization:
    // - Convert CRLF to LF
    // - Replace unicode space chars (NBSP, etc.) with regular space
    // - Trim each line & remove blanks
    // - Remove all internal whitespace from address portion
    // - Trim amount portion
    function normalizeRecipients(raw) {
      if (!raw) return '';
      return raw
        .replace(/\r\n?/g, '\n')
        .replace(/[\u00A0\u2000-\u200B\u202F\uFEFF]/g, ' ')
        .split('\n')
        .map(l => l.trim())
        .filter(l => l.length > 0)
        .map(l => {
          const idx = l.indexOf(',');
          if (idx === -1) return l; // malformed; parser will error later
          const addrPart = l.slice(0, idx);
            const amtPart  = l.slice(idx + 1);
          const addr = addrPart.replace(/\s+/g, '');
          const amt  = amtPart.trim();
          return `${addr}, ${amt}`;
        })
        .join('\n');
    }

    function applyRecipientsNormalization() {
      const before = recipientsInput.value;
      const after  = normalizeRecipients(before);
      if (before !== after) {
        recipientsInput.value = after;
        log('Recipients trimmed & normalized.', 'info');
      }
    }

    // Passive auto-trim events
    recipientsInput.addEventListener('blur', applyRecipientsNormalization);
    recipientsInput.addEventListener('change', applyRecipientsNormalization);
    recipientsInput.addEventListener('paste', () => setTimeout(applyRecipientsNormalization, 0));

    // Manual trim button
    if (trimRecipientsBtn) {
      trimRecipientsBtn.addEventListener('click', applyRecipientsNormalization);
    }

    /* -------------------- Wallet Connect -------------------- */
    connectBtn.addEventListener('click', async () => {
      const injected = window.phantom?.solana || window.solana;
      if (!injected || !injected.isPhantom) {
        log('Phantom wallet not found. Install: https://phantom.app/', 'error');
        window.open('https://phantom.app/', '_blank');
        return;
      }
      try {
        provider = injected;
        log('Requesting wallet connection...', 'info');
        const res = await provider.connect();
        wallet = provider.publicKey || res?.publicKey;
        if (!wallet) throw new Error('No public key returned.');
        log('Wallet connected.', 'success');
        log(`Address: ${wallet.toString()}`);
        connectBtn.textContent = `Connected: ${wallet.toString().slice(0,4)}...${wallet.toString().slice(-4)}`;
        connectBtn.classList.replace('bg-indigo-600','bg-slate-700');
        setUi(true);
        
        // Re-initialize connection after wallet connects
        initializeConnection();

        if (provider.on) {
          provider.on('disconnect', () => {
            log('Wallet disconnected.', 'error');
            wallet = null; provider = null;
            connectBtn.textContent = 'Connect Wallet';
            connectBtn.classList.replace('bg-slate-700','bg-indigo-600');
            setUi(false);
          });
        }
      } catch (e) {
        const msg = e?.message || String(e);
        if (e?.code === 4001) log('User rejected connection.', 'error');
        else log(`Connect error: ${msg}`, 'error');
      }
    });

    function resetSendBtn() {
      sendBtn.disabled = false;
      sendBtn.textContent = 'Prepare & Send Transactions';
    }

    /* -------------------- ATA / Transaction Builders -------------------- */
    async function ensureSenderAtaExists() {
      const info = await connection.getAccountInfo(senderAta, 'confirmed');
      if (info) return;

      log('Sender ATA missing, creating...', 'info');
      const tx = new Transaction();
      const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash('confirmed');
      tx.recentBlockhash = blockhash;
      tx.feePayer = wallet;
      tx.add(
        createAssociatedTokenAccountInstruction(
          wallet, senderAta, wallet, mintPubkey, tokenProgramId, ASSOCIATED_TOKEN_PROGRAM_ID
        )
      );
      const signed = await provider.signTransaction(tx);
      const sig = await connection.sendRawTransaction(signed.serialize(), { skipPreflight:false });
      log(`Sender ATA creation tx: ${sig}`, 'success');
      await connection.confirmTransaction({ signature:sig, blockhash, lastValidBlockHeight }, 'finalized');
      log('Sender ATA confirmed.', 'success');
    }

    async function buildBatchTx(batch) {
      const tx = new Transaction();
      const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash('confirmed');
      tx.recentBlockhash = blockhash;
      tx.feePayer = wallet;

      let ataCreations = 0;

      for (const r of batch) {
        const destAta = await getAssociatedTokenAddress(
          mintPubkey, r.address, true, tokenProgramId, ASSOCIATED_TOKEN_PROGRAM_ID
        );
        const destInfo = await connection.getAccountInfo(destAta, 'confirmed');
        if (!destInfo) {
          tx.add(
            createAssociatedTokenAccountInstruction(
              wallet, destAta, r.address, mintPubkey, tokenProgramId, ASSOCIATED_TOKEN_PROGRAM_ID
            )
          );
          ataCreations++;
        }
        tx.add(
          createTransferCheckedInstruction(
            senderAta, mintPubkey, destAta, wallet, r.amount, decimals, [], tokenProgramId
          )
        );
      }

      return { tx, ataCreations, lastValidBlockHeight };
    }

    async function confirmSig(signature, blockhash, lastValidBlockHeight, commitment='finalized') {
      const res = await connection.confirmTransaction(
        { signature, blockhash, lastValidBlockHeight },
        commitment
      );
      return !res?.value?.err;
    }

    /* -------------------- Multi-Endpoint Consensus Verification -------------------- */
    
    /**
     * Verify transaction signature on a single RPC endpoint at 'finalized' commitment level
     * @param {string} signature - Transaction signature to verify
     * @param {object} endpoint - Endpoint configuration object
     * @returns {Promise<object>} - { success: boolean, status: string, error?: string }
     */
    async function verifyTransactionOnEndpoint(signature, endpoint) {
      const fullUrl = buildEndpointUrl(endpoint);
      try {
        // Create a temporary connection to this endpoint
        const conn = new Connection(fullUrl, 'finalized');
        
        // Query the signature status with finalized commitment
        const status = await conn.getSignatureStatus(signature, {
          searchTransactionHistory: true
        });

        if (!status || !status.value) {
          return {
            success: false,
            status: 'not_found',
            error: 'Transaction not recognized by this endpoint'
          };
        }

        const confirmationStatus = status.value.confirmationStatus;
        const hasError = status.value.err;

        if (hasError) {
          return {
            success: false,
            status: 'error',
            error: JSON.stringify(hasError)
          };
        }

        if (confirmationStatus === 'finalized') {
          return {
            success: true,
            status: 'finalized'
          };
        } else if (confirmationStatus === 'confirmed') {
          return {
            success: true,
            status: 'confirmed'
          };
        } else if (confirmationStatus === 'processed') {
          return {
            success: false,
            status: 'processed',
            error: 'Only processed, not yet confirmed'
          };
        } else {
          return {
            success: false,
            status: confirmationStatus || 'unknown',
            error: 'Unexpected confirmation status'
          };
        }

      } catch (err) {
        return {
          success: false,
          status: 'error',
          error: err?.message || String(err)
        };
      }
    }

    /**
     * Perform multi-endpoint consensus verification for a transaction
     * @param {string} signature - Transaction signature to verify
     * @returns {Promise<object>} - { consensusReached: boolean, results: array, confirmedCount: number, totalCount: number }
     */
    async function performConsensusVerification(signature) {
      const endpoints = getEnabledEndpoints();
      
      if (endpoints.length === 0) {
        log(`‚ö†Ô∏è No RPC endpoints enabled for verification. Skipping consensus check.`, 'warning');
        return {
          consensusReached: false,
          results: [],
          confirmedCount: 0,
          totalCount: 0
        };
      }

      if (endpoints.length < 3) {
        log(`‚ö†Ô∏è Warning: Only ${endpoints.length} endpoint(s) enabled. Recommend at least 3 for reliable consensus.`, 'warning');
      }

      log(`üîç Multi-RPC Consensus Verification: Querying ${endpoints.length} endpoint(s)...`, 'info');

      // Query all endpoints in parallel
      const verificationPromises = endpoints.map(async (endpoint) => {
        const result = await verifyTransactionOnEndpoint(signature, endpoint);
        return {
          endpoint: endpoint.label,
          ...result
        };
      });

      const results = await Promise.all(verificationPromises);
      
      // Count how many endpoints successfully confirmed at finalized level
      const confirmedCount = results.filter(r => r.success && r.status === 'finalized').length;
      const totalCount = results.length;
      
      // Check if consensus threshold is met
      const consensusReached = confirmedCount >= minConsensusThreshold;

      // Log detailed results
      log(`üìä Consensus Verification Results:`, 'info');
      results.forEach(r => {
        if (r.success) {
          log(`  ‚úÖ ${r.endpoint}: ${r.status}`, 'success');
        } else {
          log(`  ‚ùå ${r.endpoint}: ${r.status} - ${r.error || 'Unknown error'}`, 'warning');
        }
      });

      if (consensusReached) {
        log(`‚úÖ Consensus Reached: ${confirmedCount}/${totalCount} endpoints confirmed (threshold: ${minConsensusThreshold})`, 'success');
      } else {
        log(`‚ö†Ô∏è Consensus NOT Reached: Only ${confirmedCount}/${totalCount} endpoints confirmed (threshold: ${minConsensusThreshold})`, 'warning');
        log(`‚ÑπÔ∏è This may indicate network sync delays. Check manually: https://solscan.io/tx/${signature}`, 'warning');
      }

      return {
        consensusReached,
        results,
        confirmedCount,
        totalCount
      };
    }

    /**
     * Legacy function for backward compatibility - now calls new consensus verification
     */
    async function verifyTransactionOnBackupRpc(signature) {
      const result = await performConsensusVerification(signature);
      return result.consensusReached;
    }

    async function simulateTx(tx) {
      try {
        const sim = await connection.simulateTransaction(tx, { sigVerify: false });
        return sim.value;
      } catch (e) {
        return { err: e?.message || String(e), logs: [] };
      }
    }

    // Try send a batch as a single atomic tx. Returns true on success, false on failure.
    async function trySendBatch(batch, { simulateBefore=false, attemptLabel='' } = {}) {
      try {
        const { tx, ataCreations, lastValidBlockHeight } = await buildBatchTx(batch);
        log(`${attemptLabel}Prepared batch of ${batch.length}. New ATAs: ${ataCreations}`, 'info');

        if (simulateBefore) {
          const sim = await simulateTx(tx);
          if (sim?.err) {
            log(`${attemptLabel}Simulation error: ${JSON.stringify(sim.err)}`, 'error');
            if (sim?.logs?.length) log(sim.logs.join('\n'), 'error');
            return false;
          } else {
            log(`${attemptLabel}Simulation OK.`, 'success');
          }
        }

        log(`${attemptLabel}Signing...`, 'info');
        const signed = await provider.signTransaction(tx);

        log(`${attemptLabel}Sending...`, 'info');
        const sig = await connection.sendRawTransaction(signed.serialize(), { skipPreflight:false });
        log(`${attemptLabel}TX sent: ${sig}`, 'success');

        const ok = await confirmSig(sig, tx.recentBlockhash, tx.lastValidBlockHeight ?? lastValidBlockHeight, 'finalized');
        if (!ok) {
          log(`${attemptLabel}Confirmation reported failure.`, 'error');
          return false;
        }

        const rpc = connection._rpcEndpoint || '';
        const devnetParam = (rpc.includes('devnet') || clusterSelect.value.includes('devnet')) ? '?cluster=devnet' : '';
        log(`${attemptLabel}Confirmed: https://solscan.io/tx/${sig}${devnetParam}`, 'success');

        // Perform multi-endpoint consensus verification
        const consensusResult = await performConsensusVerification(sig);
        
        // Show warning if consensus not reached (but don't fail the batch)
        if (!consensusResult.consensusReached) {
          log(`‚ö†Ô∏è Warning: Consensus verification did not reach threshold. Transaction may still be valid.`, 'warning');
        }

        return true;
      } catch (e) {
        const msg = e?.message || String(e);
        if (msg.includes('403') || msg.toLowerCase().includes('forbidden')) {
          log('RPC returned 403 (forbidden). Use a Custom RPC URL from your provider and try again.', 'error');
        } else if (msg.toLowerCase().includes('failed to get info about account')) {
          log('RPC blocked account access. Use a provider RPC URL that allows browser access.', 'error');
        }
        log(`${attemptLabel}Batch send error: ${msg}`, 'error');
        return false;
      }
    }

    // Recursive splitter: on failure, split batch into halves to isolate failing recipients
    async function processBatchRecursive(batch, depth=0) {
      const label = depth ? `[Depth ${depth}] ` : '';
      const ok = await trySendBatch(batch, { simulateBefore: false, attemptLabel: label });
      if (ok) {
        for (const r of batch) completedRecipients.add(r.address.toString());
        updateProgress();
        return;
      }

      const okRetry = await trySendBatch(batch, { simulateBefore: true, attemptLabel: `${label}[Retry] ` });
      if (okRetry) {
        for (const r of batch) completedRecipients.add(r.address.toString());
        updateProgress();
        return;
      }

      if (batch.length === 1) {
        const r = batch[0];
        failedRecipients.push(r);
        log(`${label}Recipient failed permanently: ${r.address.toString()}`, 'error');
        updateProgress();
        return;
      }

      const mid = Math.floor(batch.length / 2);
      const left = batch.slice(0, mid);
      const right = batch.slice(mid);

      log(`${label}Splitting batch (${batch.length}) into ${left.length} + ${right.length} to isolate failures...`, 'error');

      await processBatchRecursive(left, depth + 1);
      await processBatchRecursive(right, depth + 1);
    }

    /* -------------------- Send Handler -------------------- */
    sendBtn.addEventListener('click', async () => {
      if (!wallet) { log('Connect wallet first.', 'error'); return; }

      sendBtn.disabled = true;
      sendBtn.textContent = 'Processing...';
      resetProgress();
      log('Starting multisend with retries...', 'info');

      const mintStr = mintInput.value.trim();

      // Safety normalization before parsing recipients (even if user never blurred or clicked Trim)
      applyRecipientsNormalization();
      const listStr = recipientsInput.value.trim();

      const batchSize  = parseInt(batchSizeInput.value,10);

      if (!mintStr) { log('Mint address required.', 'error'); resetSendBtn(); return; }
      if (!listStr)  { log('Recipients list empty.', 'error'); resetSendBtn(); return; }
      if (isNaN(batchSize) || batchSize <= 0 || batchSize > 12) {
        log('Batch size 1‚Äì12 required.', 'error'); resetSendBtn(); return;
      }

      try {
        // Ensure connection is initialized with the primary endpoint
        if (!connection) {
          initializeConnection();
        }
        
        log(`Using RPC: ${connection._rpcEndpoint}`, 'info');
        
        // Validate endpoint configuration
        const enabledEndpoints = getEnabledEndpoints();
        log(`Verification endpoints enabled: ${enabledEndpoints.length}`, 'info');
        
        if (enabledEndpoints.length < 3) {
          log(`‚ö†Ô∏è Warning: Less than 3 RPC endpoints enabled for verification. Recommend enabling at least 3.`, 'warning');
          log(`‚ÑπÔ∏è Go to "RPC Nodes for Verification" section to configure endpoints.`, 'warning');
        } else {
          log(`‚úì Using ${enabledEndpoints.length} endpoints for consensus verification (threshold: ${minConsensusThreshold})`, 'info');
        }
        
        mintPubkey = new PublicKey(mintStr);

        // Detect token program by mint owner
        const mintAcct = await connection.getAccountInfo(mintPubkey, 'confirmed');
        if (!mintAcct) throw new Error('Mint account not found on this cluster.');
        const token2022 = TOKEN_2022_PROGRAM_ID ?? TOKEN_PROGRAM_ID;
        tokenProgramId = mintAcct.owner?.toString() === token2022.toString() ? token2022 : TOKEN_PROGRAM_ID;
        log(`Program: ${tokenProgramId.toString() === TOKEN_PROGRAM_ID.toString() ? 'SPL Token (legacy)' : 'Token-2022'}`, 'info');

        const mintInfo = await getMint(connection, mintPubkey, 'confirmed', tokenProgramId);
        decimals = mintInfo.decimals;
        log(`Decimals: ${decimals}`, 'info');

        // Sender ATA
        senderAta = await getAssociatedTokenAddress(
          mintPubkey, wallet, true, tokenProgramId, ASSOCIATED_TOKEN_PROGRAM_ID
        );
        log(`Sender ATA: ${senderAta.toString()}`, 'info');

        await ensureSenderAtaExists();

        // Parse recipients
        const lines = listStr.split('\n').filter(l => l.trim() !== '');
        const recipients = [];
        for (const [i, raw] of lines.entries()) {
          const parts = raw.split(',').map(s => s.trim());
          if (parts.length !== 2)
            throw new Error(`Invalid line #${i+1}: "${raw}" (expected "address, amount")`);
          const [addrStr, amtStr] = parts;
          let pk;
          try { pk = new PublicKey(addrStr); }
          catch { throw new Error(`Bad address line #${i+1}: ${addrStr}`); }
            const amount = decimalToAmount(amtStr, decimals);
          if (amount <= 0n) throw new Error(`Amount must be > 0 line #${i+1}`);
          recipients.push({ address: pk, amount });
        }

        allRecipients = recipients.slice();
        updateProgress();

        const total = recipients.reduce((s,r)=>s+r.amount, 0n);
        log(`Recipients: ${recipients.length}, Total: ${formatAmount(total, decimals)} tokens.`, 'info');

        // Optional: sender token balance
        try {
          const bal = await connection.getTokenAccountBalance(senderAta, 'confirmed');
          log(`Sender balance (approx): ${bal?.value?.uiAmountString ?? '0'}`, 'info');
        } catch (_) {}

        // Create batches
        const batches = [];
        for (let i=0; i<recipients.length; i+=batchSize) {
          batches.push(recipients.slice(i, i+batchSize));
        }
        log(`Batches: ${batches.length} (size ${batchSize})`, 'info');

        // Process batches sequentially with recursive splitting
        for (let i=0; i<batches.length; i++) {
          const batch = batches[i].filter(r => !completedRecipients.has(r.address.toString()));
          if (batch.length === 0) continue;

          log(`--- Batch ${i+1}/${batches.length} (recipients: ${batch.length}) ---`, 'info');
          await processBatchRecursive(batch, 0);
        }

        // Final reconciliation log
        log(`Completed: ${completedRecipients.size} / ${allRecipients.length}`, 'success');
        if (failedRecipients.length > 0) {
          log(`Failed recipients: ${failedRecipients.length}`, 'error');
          for (const r of failedRecipients) {
            log(` - ${r.address.toString()} (${formatAmount(r.amount, decimals)})`, 'error');
          }
          log('Tip: If you saw 403/forbidden earlier, ensure your Custom RPC URL is set and valid.', 'error');
        } else {
          log('All recipients processed successfully.', 'success');
        }

      } catch (err) {
        const msg = err?.message || String(err);
        if (msg.includes('403') || msg.toLowerCase().includes('forbidden')) {
          log('RPC returned 403 (forbidden). Use a Custom RPC URL from your provider and try again.', 'error');
        }
        log(`Error: ${msg}`, 'error');
        if (err?.stack) log(err.stack, 'error');
      } finally {
        resetSendBtn();
      }
    });
  </script>
</body>
</html>
