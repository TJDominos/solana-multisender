<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Solana Token Multisender</title>

  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    #log-output::-webkit-scrollbar { width:4px; }
    #log-output::-webkit-scrollbar-track { background:#334155; }
    #log-output::-webkit-scrollbar-thumb { background:#64748b; border-radius:4px; }
  </style>
</head>
<body class="bg-slate-900 text-slate-100 font-sans p-4 md:p-8 min-h-screen">
  <div class="max-w-5xl mx-auto">
    <header class="mb-8">
      <h1 class="text-3xl md:text-4xl font-bold text-white mb-2">Solana Token Multisender</h1>
      <p class="text-slate-400">Connect your wallet, paste the mint address, and send SPL tokens to many recipients. Includes progress, retry logic, and trimming utilities.</p>
    </header>

    <div class="bg-yellow-900 border border-yellow-700 text-yellow-100 px-4 py-3 rounded-lg mb-6 shadow" role="alert">
      <p class="font-bold">Use at Your Own Risk!</p>
      <p class="text-sm">Always test on Devnet before Mainnet. Verify all addresses and amounts.</p>
    </div>

    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
      <!-- Left: inputs -->
      <div class="bg-slate-800 p-6 rounded-lg shadow flex flex-col gap-6">
        <div>
          <h2 class="text-lg font-semibold mb-2">1. Connect Wallet & Select Cluster</h2>
          <button id="connect-wallet-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition">
            Connect Wallet
          </button>
          <select id="cluster-select" class="w-full bg-slate-700 text-white border border-slate-600 rounded-lg p-2 mt-2">
            <option value="https://api.devnet.solana.com">Devnet (Testing)</option>
            <option value="https://api.mainnet-beta.solana.com">Mainnet-beta (Public)</option>
          </select>

          <!-- Custom RPC URL -->
          <label for="rpc-url" class="block text-sm font-medium text-slate-300 mt-3">Optional: Custom RPC URL (recommended for Mainnet)</label>
          <input id="rpc-url" type="text"
                 value="https://mainnet.helius-rpc.com/?api-key=fda76be1-7d09-4880-80db-837831934193"
                 placeholder="e.g. https://rpc.helius.xyz/?api-key=YOUR_KEY"
                 class="w-full bg-slate-700 text-white border border-slate-600 rounded-lg p-2"
                 autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" inputmode="url">
          <p class="text-xs text-slate-400 mt-1">If provided, this overrides the dropdown. Many public endpoints block browser requests; use your provider URL.</p>

          <p id="connect-hint" class="text-xs text-slate-400 mt-2">Please connect your wallet first to enable the form.</p>
        </div>

        <div>
          <label for="token-mint-address" class="block text-sm font-medium text-slate-300 mb-1">2. Token Mint Address</label>
          <input id="token-mint-address" type="text" disabled
                 autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" inputmode="text"
                 class="w-full bg-slate-700 text-white border border-slate-600 rounded-lg p-2"
                 placeholder="Base58 mint address (e.g., EPjFW...)">
        </div>

        <div>
          <label for="batch-size" class="block text-sm font-medium text-slate-300 mb-1">3. Transfers per Transaction (Batch Size)</label>
          <input id="batch-size" type="number" value="5" min="1" max="12" disabled
                 class="w-full bg-slate-700 text-white border border-slate-600 rounded-lg p-2">
          <p class="text-xs text-slate-400 mt-1">If creating many ATAs, use 3‚Äì6 to avoid tx size limits.</p>
        </div>

        <div>
          <label for="recipients-list" class="block text-sm font-medium text-slate-300 mb-1">
            4. Recipients (one per line: Address, Amount)
          </label>
          <textarea id="recipients-list" rows="10" disabled
            class="w-full bg-slate-700 text-white border border-slate-600 rounded-lg p-2 font-mono text-sm"
            placeholder="Address, Amount
Address, Amount
Example:
Hc4q...abcd, 10.5
CxtR...wxyz, 2"></textarea>
          <button id="trim-recipients-btn"
                  type="button"
                  class="mt-2 bg-slate-600 hover:bg-slate-700 text-white text-xs py-1 px-3 rounded transition">
            Trim Recipients
          </button>
          <p class="text-xs text-slate-400 mt-1">
            Trims leading/trailing spaces, removes blank lines & unicode spaces, and strips spaces inside addresses.
          </p>
        </div>

        <button id="send-btn" disabled
          class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition disabled:bg-gray-500">
          Connect Wallet to Start
        </button>

        <!-- Progress -->
        <div class="mt-4">
          <div class="flex items-center justify-between text-sm text-slate-300 mb-1">
            <span>Progress</span>
            <span id="progress-label">0 / 0 (0%)</span>
          </div>
          <div id="progress-bar-wrapper" class="w-full bg-slate-700 h-3 rounded overflow-hidden">
            <div id="progress-bar" class="bg-green-500 h-3 w-0 transition-all duration-300"></div>
          </div>
          <div class="grid grid-cols-3 gap-2 text-xs text-slate-400 mt-2">
            <div>Completed: <span id="count-completed">0</span></div>
            <div>Pending: <span id="count-pending">0</span></div>
            <div>Failed: <span id="count-failed">0</span></div>
          </div>
        </div>
      </div>

      <!-- Right: log -->
      <div class="bg-slate-800 p-6 rounded-lg shadow flex flex-col">
        <h2 class="text-lg font-semibold mb-2 text-white">Log & Progress</h2>
        
        <!-- Cross-RPC Verification Info -->
        <div class="bg-blue-900/30 border border-blue-700/50 rounded-lg p-3 mb-3 text-xs">
          <div class="flex items-start gap-2">
            <span class="text-blue-400 font-bold text-sm">üîç</span>
            <div class="text-blue-200">
              <strong>Cross-RPC Verification:</strong> Each transaction is verified on a backup RPC provider for added security.
              <span class="text-blue-300 block mt-1">
                ‚úÖ Green = Backup RPC confirms transaction | 
                ‚ö†Ô∏è Yellow = Warning (may need time to sync)
              </span>
            </div>
          </div>
        </div>

        <div id="log-output"
             class="w-full h-96 bg-slate-900 rounded-lg p-4 font-mono text-sm text-slate-300 overflow-y-auto whitespace-pre-wrap break-words">
          Welcome! Connect your wallet to begin.
        </div>
        <button id="clear-log-btn"
                class="mt-4 bg-slate-600 hover:bg-slate-700 text-white text-sm py-2 px-4 rounded-lg transition">
          Clear Log
        </button>
      </div>
    </div>

    <footer class="text-center text-slate-500 mt-8 text-sm">
      Includes automatic retries with batch splitting, progress bar, custom RPC support, and manual + passive trimming.
    </footer>
  </div>

  <!-- Use ESM imports to avoid global splToken issues -->
  <script type="module">
    import { Connection, PublicKey, Transaction } from 'https://esm.sh/@solana/web3.js@1.95.3';
    import {
      getMint,
      getAssociatedTokenAddress,
      createAssociatedTokenAccountInstruction,
      createTransferCheckedInstruction,
      TOKEN_PROGRAM_ID,
      TOKEN_2022_PROGRAM_ID,
      ASSOCIATED_TOKEN_PROGRAM_ID,
    } from 'https://esm.sh/@solana/spl-token@0.4.6';

    /* -------------------- UI References -------------------- */
    const connectBtn      = document.getElementById('connect-wallet-btn');
    const clusterSelect   = document.getElementById('cluster-select');
    const rpcUrlInput     = document.getElementById('rpc-url');
    const mintInput       = document.getElementById('token-mint-address');
    const recipientsInput = document.getElementById('recipients-list');
    const trimRecipientsBtn = document.getElementById('trim-recipients-btn');
    const batchSizeInput  = document.getElementById('batch-size');
    const sendBtn         = document.getElementById('send-btn');
    const hint            = document.getElementById('connect-hint');
    const clearLogBtn     = document.getElementById('clear-log-btn');
    const logOutput       = document.getElementById('log-output');

    // Progress UI
    const progressBar     = document.getElementById('progress-bar');
    const progressLabel   = document.getElementById('progress-label');
    const countCompleted  = document.getElementById('count-completed');
    const countPending    = document.getElementById('count-pending');
    const countFailed     = document.getElementById('count-failed');

    /* -------------------- State -------------------- */
    let provider = null; // Phantom provider
    let wallet   = null; // PublicKey
    let connection = null;

    // Mint/session state set during send
    let mintPubkey = null;
    let tokenProgramId = TOKEN_PROGRAM_ID;
    let decimals = 0;
    let senderAta = null;

    // Backup RPC connections for cross-RPC verification
    let backupConnection = null;

    // Results
    let allRecipients = [];
    let completedRecipients = new Set();
    let failedRecipients = [];

    /* -------------------- Logging -------------------- */
    function log(msg, type='info') {
      const ts = new Date().toLocaleTimeString();
      const color = type === 'error' ? 'text-red-400'
                  : type === 'success' ? 'text-green-400'
                  : type === 'warning' ? 'text-yellow-400'
                  : 'text-slate-300';
      logOutput.innerHTML += `\n<div class="${color}"><span class="text-slate-500">${ts}:</span> ${msg}</div>`;
      logOutput.scrollTop = logOutput.scrollHeight;
    }
    clearLogBtn.addEventListener('click', () => { logOutput.innerHTML = 'Log cleared.'; });

    /* -------------------- UI Helpers -------------------- */
    function setUi(connected) {
      mintInput.disabled       = !connected;
      recipientsInput.disabled = !connected;
      batchSizeInput.disabled  = !connected;
      sendBtn.disabled         = !connected;
      sendBtn.textContent      = connected ? 'Prepare & Send Transactions' : 'Connect Wallet to Start';
      hint.textContent         = connected
        ? 'Wallet connected. Enter mint & recipients.'
        : 'Please connect your wallet first to enable the form.';
    }

    function updateProgress() {
      const total  = allRecipients.length;
      const done   = completedRecipients.size;
      const failed = failedRecipients.length;
      const pending = Math.max(0, total - done - failed);
      const pct = total > 0 ? Math.round((done / total) * 100) : 0;

      progressBar.style.width = pct + '%';
      progressLabel.textContent = `${done} / ${total} (${pct}%)`;
      countCompleted.textContent = String(done);
      countPending.textContent   = String(pending);
      countFailed.textContent    = String(failed);
    }

    function resetProgress() {
      allRecipients = [];
      completedRecipients = new Set();
      failedRecipients = [];
      updateProgress();
    }

    /* -------------------- Persistent Custom RPC -------------------- */
    document.addEventListener('DOMContentLoaded', () => {
      const savedRpc = localStorage.getItem('customRpcUrl');
      if (savedRpc && !rpcUrlInput.value) {
        rpcUrlInput.value = savedRpc;
      }
      setUi(false);
      resetProgress();
    });
    rpcUrlInput.addEventListener('change', () => {
      localStorage.setItem('customRpcUrl', rpcUrlInput.value.trim());
    });

    /* -------------------- Amount Helpers (BigInt) -------------------- */
    function decimalToAmount(str, decimals) {
      const s = String(str).trim();
      if (!/^\d+(?:\.\d+)?$/.test(s)) throw new Error(`Invalid amount: ${str}`);
      const [whole, fracRaw=''] = s.split('.');
      const frac = (fracRaw + '0'.repeat(decimals)).slice(0, decimals);
      return BigInt(whole + frac);
    }

    function formatAmount(bi, decimals) {
      const s = bi.toString();
      if (decimals === 0) return s;
      const pad = s.padStart(decimals + 1, '0');
      const whole = pad.slice(0, -decimals);
      const frac  = pad.slice(-decimals).replace(/0+$/,'');
      return frac ? `${whole}.${frac}` : whole;
    }

    /* -------------------- Recipients Normalization -------------------- */
    // Robust normalization:
    // - Convert CRLF to LF
    // - Replace unicode space chars (NBSP, etc.) with regular space
    // - Trim each line & remove blanks
    // - Remove all internal whitespace from address portion
    // - Trim amount portion
    function normalizeRecipients(raw) {
      if (!raw) return '';
      return raw
        .replace(/\r\n?/g, '\n')
        .replace(/[\u00A0\u2000-\u200B\u202F\uFEFF]/g, ' ')
        .split('\n')
        .map(l => l.trim())
        .filter(l => l.length > 0)
        .map(l => {
          const idx = l.indexOf(',');
          if (idx === -1) return l; // malformed; parser will error later
          const addrPart = l.slice(0, idx);
            const amtPart  = l.slice(idx + 1);
          const addr = addrPart.replace(/\s+/g, '');
          const amt  = amtPart.trim();
          return `${addr}, ${amt}`;
        })
        .join('\n');
    }

    function applyRecipientsNormalization() {
      const before = recipientsInput.value;
      const after  = normalizeRecipients(before);
      if (before !== after) {
        recipientsInput.value = after;
        log('Recipients trimmed & normalized.', 'info');
      }
    }

    // Passive auto-trim events
    recipientsInput.addEventListener('blur', applyRecipientsNormalization);
    recipientsInput.addEventListener('change', applyRecipientsNormalization);
    recipientsInput.addEventListener('paste', () => setTimeout(applyRecipientsNormalization, 0));

    // Manual trim button
    if (trimRecipientsBtn) {
      trimRecipientsBtn.addEventListener('click', applyRecipientsNormalization);
    }

    /* -------------------- Wallet Connect -------------------- */
    connectBtn.addEventListener('click', async () => {
      const injected = window.phantom?.solana || window.solana;
      if (!injected || !injected.isPhantom) {
        log('Phantom wallet not found. Install: https://phantom.app/', 'error');
        window.open('https://phantom.app/', '_blank');
        return;
      }
      try {
        provider = injected;
        log('Requesting wallet connection...', 'info');
        const res = await provider.connect();
        wallet = provider.publicKey || res?.publicKey;
        if (!wallet) throw new Error('No public key returned.');
        log('Wallet connected.', 'success');
        log(`Address: ${wallet.toString()}`);
        connectBtn.textContent = `Connected: ${wallet.toString().slice(0,4)}...${wallet.toString().slice(-4)}`;
        connectBtn.classList.replace('bg-indigo-600','bg-slate-700');
        setUi(true);

        if (provider.on) {
          provider.on('disconnect', () => {
            log('Wallet disconnected.', 'error');
            wallet = null; provider = null;
            connectBtn.textContent = 'Connect Wallet';
            connectBtn.classList.replace('bg-slate-700','bg-indigo-600');
            setUi(false);
          });
        }
      } catch (e) {
        const msg = e?.message || String(e);
        if (e?.code === 4001) log('User rejected connection.', 'error');
        else log(`Connect error: ${msg}`, 'error');
      }
    });

    function resetSendBtn() {
      sendBtn.disabled = false;
      sendBtn.textContent = 'Prepare & Send Transactions';
    }

    /* -------------------- ATA / Transaction Builders -------------------- */
    async function ensureSenderAtaExists() {
      const info = await connection.getAccountInfo(senderAta, 'confirmed');
      if (info) return;

      log('Sender ATA missing, creating...', 'info');
      const tx = new Transaction();
      const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash('confirmed');
      tx.recentBlockhash = blockhash;
      tx.feePayer = wallet;
      tx.add(
        createAssociatedTokenAccountInstruction(
          wallet, senderAta, wallet, mintPubkey, tokenProgramId, ASSOCIATED_TOKEN_PROGRAM_ID
        )
      );
      const signed = await provider.signTransaction(tx);
      const sig = await connection.sendRawTransaction(signed.serialize(), { skipPreflight:false });
      log(`Sender ATA creation tx: ${sig}`, 'success');
      await connection.confirmTransaction({ signature:sig, blockhash, lastValidBlockHeight }, 'confirmed');
      log('Sender ATA confirmed.', 'success');
    }

    async function buildBatchTx(batch) {
      const tx = new Transaction();
      const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash('confirmed');
      tx.recentBlockhash = blockhash;
      tx.feePayer = wallet;

      let ataCreations = 0;

      for (const r of batch) {
        const destAta = await getAssociatedTokenAddress(
          mintPubkey, r.address, true, tokenProgramId, ASSOCIATED_TOKEN_PROGRAM_ID
        );
        const destInfo = await connection.getAccountInfo(destAta, 'confirmed');
        if (!destInfo) {
          tx.add(
            createAssociatedTokenAccountInstruction(
              wallet, destAta, r.address, mintPubkey, tokenProgramId, ASSOCIATED_TOKEN_PROGRAM_ID
            )
          );
          ataCreations++;
        }
        tx.add(
          createTransferCheckedInstruction(
            senderAta, mintPubkey, destAta, wallet, r.amount, decimals, [], tokenProgramId
          )
        );
      }

      return { tx, ataCreations, lastValidBlockHeight };
    }

    async function confirmSig(signature, blockhash, lastValidBlockHeight, commitment='confirmed') {
      const res = await connection.confirmTransaction(
        { signature, blockhash, lastValidBlockHeight },
        commitment
      );
      return !res?.value?.err;
    }

    /* -------------------- Cross-RPC Verification -------------------- */
    // Get the appropriate backup RPC URL based on current cluster
    function getBackupRpcUrl() {
      const rpc = connection._rpcEndpoint || '';
      const isDevnet = rpc.includes('devnet') || clusterSelect.value.includes('devnet');
      return isDevnet 
        ? 'https://api.devnet.solana.com'
        : 'https://api.mainnet-beta.solana.com';
    }

    // Verify transaction signature on a backup RPC provider
    async function verifyTransactionOnBackupRpc(signature) {
      const backupUrl = getBackupRpcUrl();
      try {
        log(`üîç Cross-RPC Verification: Querying backup RPC (${backupUrl})...`, 'info');
        
        // Create a temporary connection to backup RPC
        const backupConn = new Connection(backupUrl, 'finalized');
        
        // Query the signature status with finalized commitment
        const status = await backupConn.getSignatureStatus(signature, {
          searchTransactionHistory: true
        });

        if (!status || !status.value) {
          log(`‚ö†Ô∏è Cross-RPC Verification: Backup RPC does not recognize transaction ${signature}`, 'warning');
          log(`‚ÑπÔ∏è This may be normal if the backup RPC hasn't synced yet. Wait a moment and check manually.`, 'warning');
          return false;
        }

        const confirmations = status.value.confirmations;
        const confirmationStatus = status.value.confirmationStatus;
        const hasError = status.value.err;

        if (hasError) {
          log(`‚ùå Cross-RPC Verification: Backup RPC shows transaction error: ${JSON.stringify(hasError)}`, 'error');
          return false;
        }

        if (confirmationStatus === 'finalized') {
          log(`‚úÖ Cross-RPC Verification: Transaction confirmed on backup RPC (finalized)`, 'success');
          return true;
        } else if (confirmationStatus === 'confirmed' || confirmationStatus === 'processed') {
          log(`‚úì Cross-RPC Verification: Transaction found on backup RPC (${confirmationStatus}, ${confirmations} confirmations)`, 'success');
          log(`‚ÑπÔ∏è Transaction is not yet finalized on backup RPC but is recognized.`, 'info');
          return true;
        } else {
          log(`‚ö†Ô∏è Cross-RPC Verification: Unexpected status: ${confirmationStatus}`, 'warning');
          return false;
        }

      } catch (err) {
        const msg = err?.message || String(err);
        log(`‚ö†Ô∏è Cross-RPC Verification: Error querying backup RPC: ${msg}`, 'warning');
        log(`‚ÑπÔ∏è This doesn't mean the transaction failed - it may be a temporary network issue.`, 'info');
        return false;
      }
    }

    async function simulateTx(tx) {
      try {
        const sim = await connection.simulateTransaction(tx, { sigVerify: false });
        return sim.value;
      } catch (e) {
        return { err: e?.message || String(e), logs: [] };
      }
    }

    // Try send a batch as a single atomic tx. Returns true on success, false on failure.
    async function trySendBatch(batch, { simulateBefore=false, attemptLabel='' } = {}) {
      try {
        const { tx, ataCreations, lastValidBlockHeight } = await buildBatchTx(batch);
        log(`${attemptLabel}Prepared batch of ${batch.length}. New ATAs: ${ataCreations}`, 'info');

        if (simulateBefore) {
          const sim = await simulateTx(tx);
          if (sim?.err) {
            log(`${attemptLabel}Simulation error: ${JSON.stringify(sim.err)}`, 'error');
            if (sim?.logs?.length) log(sim.logs.join('\n'), 'error');
            return false;
          } else {
            log(`${attemptLabel}Simulation OK.`, 'success');
          }
        }

        log(`${attemptLabel}Signing...`, 'info');
        const signed = await provider.signTransaction(tx);

        log(`${attemptLabel}Sending...`, 'info');
        const sig = await connection.sendRawTransaction(signed.serialize(), { skipPreflight:false });
        log(`${attemptLabel}TX sent: ${sig}`, 'success');

        const ok = await confirmSig(sig, tx.recentBlockhash, tx.lastValidBlockHeight ?? lastValidBlockHeight, 'confirmed');
        if (!ok) {
          log(`${attemptLabel}Confirmation reported failure.`, 'error');
          return false;
        }

        const rpc = connection._rpcEndpoint || '';
        const devnetParam = (rpc.includes('devnet') || clusterSelect.value.includes('devnet')) ? '?cluster=devnet' : '';
        log(`${attemptLabel}Confirmed: https://solscan.io/tx/${sig}${devnetParam}`, 'success');

        // Perform cross-RPC verification
        await verifyTransactionOnBackupRpc(sig);

        return true;
      } catch (e) {
        const msg = e?.message || String(e);
        if (msg.includes('403') || msg.toLowerCase().includes('forbidden')) {
          log('RPC returned 403 (forbidden). Use a Custom RPC URL from your provider and try again.', 'error');
        } else if (msg.toLowerCase().includes('failed to get info about account')) {
          log('RPC blocked account access. Use a provider RPC URL that allows browser access.', 'error');
        }
        log(`${attemptLabel}Batch send error: ${msg}`, 'error');
        return false;
      }
    }

    // Recursive splitter: on failure, split batch into halves to isolate failing recipients
    async function processBatchRecursive(batch, depth=0) {
      const label = depth ? `[Depth ${depth}] ` : '';
      const ok = await trySendBatch(batch, { simulateBefore: false, attemptLabel: label });
      if (ok) {
        for (const r of batch) completedRecipients.add(r.address.toString());
        updateProgress();
        return;
      }

      const okRetry = await trySendBatch(batch, { simulateBefore: true, attemptLabel: `${label}[Retry] ` });
      if (okRetry) {
        for (const r of batch) completedRecipients.add(r.address.toString());
        updateProgress();
        return;
      }

      if (batch.length === 1) {
        const r = batch[0];
        failedRecipients.push(r);
        log(`${label}Recipient failed permanently: ${r.address.toString()}`, 'error');
        updateProgress();
        return;
      }

      const mid = Math.floor(batch.length / 2);
      const left = batch.slice(0, mid);
      const right = batch.slice(mid);

      log(`${label}Splitting batch (${batch.length}) into ${left.length} + ${right.length} to isolate failures...`, 'error');

      await processBatchRecursive(left, depth + 1);
      await processBatchRecursive(right, depth + 1);
    }

    /* -------------------- Send Handler -------------------- */
    sendBtn.addEventListener('click', async () => {
      if (!wallet) { log('Connect wallet first.', 'error'); return; }

      sendBtn.disabled = true;
      sendBtn.textContent = 'Processing...';
      resetProgress();
      log('Starting multisend with retries...', 'info');

      const dropdownUrl = clusterSelect.value;
      const customRpc   = rpcUrlInput.value.trim();
      const rpcUrl      = customRpc || dropdownUrl;

      const mintStr = mintInput.value.trim();

      // Safety normalization before parsing recipients (even if user never blurred or clicked Trim)
      applyRecipientsNormalization();
      const listStr = recipientsInput.value.trim();

      const batchSize  = parseInt(batchSizeInput.value,10);

      if (!mintStr) { log('Mint address required.', 'error'); resetSendBtn(); return; }
      if (!listStr)  { log('Recipients list empty.', 'error'); resetSendBtn(); return; }
      if (isNaN(batchSize) || batchSize <= 0 || batchSize > 12) {
        log('Batch size 1‚Äì12 required.', 'error'); resetSendBtn(); return;
      }

      try {
        log(`RPC: ${rpcUrl}`, 'info');
        connection = new Connection(rpcUrl, 'confirmed');
        
        // Log backup RPC info
        const backupRpcUrl = rpcUrl.includes('devnet') || dropdownUrl.includes('devnet')
          ? 'https://api.devnet.solana.com'
          : 'https://api.mainnet-beta.solana.com';
        log(`Backup RPC for verification: ${backupRpcUrl}`, 'info');
        
        mintPubkey = new PublicKey(mintStr);

        // Detect token program by mint owner
        const mintAcct = await connection.getAccountInfo(mintPubkey, 'confirmed');
        if (!mintAcct) throw new Error('Mint account not found on this cluster.');
        const token2022 = TOKEN_2022_PROGRAM_ID ?? TOKEN_PROGRAM_ID;
        tokenProgramId = mintAcct.owner?.toString() === token2022.toString() ? token2022 : TOKEN_PROGRAM_ID;
        log(`Program: ${tokenProgramId.toString() === TOKEN_PROGRAM_ID.toString() ? 'SPL Token (legacy)' : 'Token-2022'}`, 'info');

        const mintInfo = await getMint(connection, mintPubkey, 'confirmed', tokenProgramId);
        decimals = mintInfo.decimals;
        log(`Decimals: ${decimals}`, 'info');

        // Sender ATA
        senderAta = await getAssociatedTokenAddress(
          mintPubkey, wallet, true, tokenProgramId, ASSOCIATED_TOKEN_PROGRAM_ID
        );
        log(`Sender ATA: ${senderAta.toString()}`, 'info');

        await ensureSenderAtaExists();

        // Parse recipients
        const lines = listStr.split('\n').filter(l => l.trim() !== '');
        const recipients = [];
        for (const [i, raw] of lines.entries()) {
          const parts = raw.split(',').map(s => s.trim());
          if (parts.length !== 2)
            throw new Error(`Invalid line #${i+1}: "${raw}" (expected "address, amount")`);
          const [addrStr, amtStr] = parts;
          let pk;
          try { pk = new PublicKey(addrStr); }
          catch { throw new Error(`Bad address line #${i+1}: ${addrStr}`); }
            const amount = decimalToAmount(amtStr, decimals);
          if (amount <= 0n) throw new Error(`Amount must be > 0 line #${i+1}`);
          recipients.push({ address: pk, amount });
        }

        allRecipients = recipients.slice();
        updateProgress();

        const total = recipients.reduce((s,r)=>s+r.amount, 0n);
        log(`Recipients: ${recipients.length}, Total: ${formatAmount(total, decimals)} tokens.`, 'info');

        // Optional: sender token balance
        try {
          const bal = await connection.getTokenAccountBalance(senderAta, 'confirmed');
          log(`Sender balance (approx): ${bal?.value?.uiAmountString ?? '0'}`, 'info');
        } catch (_) {}

        // Create batches
        const batches = [];
        for (let i=0; i<recipients.length; i+=batchSize) {
          batches.push(recipients.slice(i, i+batchSize));
        }
        log(`Batches: ${batches.length} (size ${batchSize})`, 'info');

        // Process batches sequentially with recursive splitting
        for (let i=0; i<batches.length; i++) {
          const batch = batches[i].filter(r => !completedRecipients.has(r.address.toString()));
          if (batch.length === 0) continue;

          log(`--- Batch ${i+1}/${batches.length} (recipients: ${batch.length}) ---`, 'info');
          await processBatchRecursive(batch, 0);
        }

        // Final reconciliation log
        log(`Completed: ${completedRecipients.size} / ${allRecipients.length}`, 'success');
        if (failedRecipients.length > 0) {
          log(`Failed recipients: ${failedRecipients.length}`, 'error');
          for (const r of failedRecipients) {
            log(` - ${r.address.toString()} (${formatAmount(r.amount, decimals)})`, 'error');
          }
          log('Tip: If you saw 403/forbidden earlier, ensure your Custom RPC URL is set and valid.', 'error');
        } else {
          log('All recipients processed successfully.', 'success');
        }

      } catch (err) {
        const msg = err?.message || String(err);
        if (msg.includes('403') || msg.toLowerCase().includes('forbidden')) {
          log('RPC returned 403 (forbidden). Use a Custom RPC URL from your provider and try again.', 'error');
        }
        log(`Error: ${msg}`, 'error');
        if (err?.stack) log(err.stack, 'error');
      } finally {
        resetSendBtn();
      }
    });
  </script>
</body>
</html>
